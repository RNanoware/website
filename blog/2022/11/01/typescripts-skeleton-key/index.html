<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    

    

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Typescript's Skeleton Key | Neill Robson's Website</title>

    <script type="module">
      document.documentElement.classList.remove('no-js');
      document.documentElement.classList.add('js');
    </script>

    <meta name="description" content="Typescript's Skeleton Key" />
    <meta name="keywords" content="" />
    <meta name="author" content="Neill Robson">

    <meta property="og:title" content="Typescript's Skeleton Key | Neill Robson's Website">
    <meta property="og:description" content="Typescript's Skeleton Key">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://neillrobson.com/blog/2022/11/01/typescripts-skeleton-key/">
    <link rel="canonical" href="https://neillrobson.com/blog/2022/11/01/typescripts-skeleton-key/">

    

    <link rel="shortcut icon" href="/assets/favicon/favicon.ico" type="image/x-icon">
    <link type="application/atom+xml" rel="alternate" href="https://neillrobson.com/feed.xml" title="Neill Robson&apos;s Website" />

    <link rel="stylesheet" href="/assets/css/main.css">

    
</head>


  <body>
    <div class="container">
      <div class="header">
  <div id="title">
    
    
    <a href="/">
      <img
        id="logo"
        class="rounded"
        src="https://gravatar.com/avatar/e246fc5b45d5e2859ecbf2b867e4b5bb30d5e3d079c412add3acdd5ba87b07ce?s=64&d=https%3A%2F%2Fneillrobson.com%2Fassets%2Fimages%2F2023-profile.jpg"
        alt="Neill Robson"
      />
      Neill Robson's Website
    </a>
  </div>
  <div class="nav">
    
    <a href="/" title="About">About</a>
    
    <a href="/blog" title="Blog">Blog</a>
    
    <a href="/archive" title="Archive">Archive</a>
    
    <a href="/projects" title="Projects">Projects</a>
    
    <a href="/contact" title="Contact">Contact</a>
    
    <a href="/feed.xml" title="RSS">RSS</a>
    
  </div>
</div>


      <div class="main">
        <div class="entry">
    <a class="small date left margin" href="/blog/2022/11/01/typescripts-skeleton-key/">November 1, 2022</a>
    <h1>Typescript's Skeleton Key</h1>

    <p>The intrepid Typescript developer will find several types that, frankly, make no sense whatsoever in real life. A “string” or “number” is perfectly reasonable, but what is an “unknown” or “never” type?</p>

<p>More importantly, what in the world is a “keyof never”?</p>

<!--more-->

<div class="margin right">  <p>In case the introduction didn’t make the fact clear, this post will be pretty technical. Be forewarned!</p>
</div>

<p>First, we’ll need a bit of background on how types can be combined in Typescript to create new, more complicated types. The rules take after formal logic and set theory, but the end result is still pretty intuitive.</p>

<p>Let’s pretend we have two plain object types, <code>Vehicle</code> and <code>Animal</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Vehicle</span> <span class="p">{</span>
    <span class="nl">speed</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">legs</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="union">Union</h2>

<p>Perhaps we also want a function that accepts either a <code>Vehicle</code> or <code>Animal</code> and returns its name. How would we write that function and its signature?</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getName</span><span class="p">(</span><span class="nx">entity</span><span class="p">:</span> <span class="nx">Vehicle</span> <span class="o">|</span> <span class="nx">Animal</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">entity</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice a few things about this function:</p>

<ul>
  <li>
    <p>The parameter can either be a <code>Vehicle</code> or <code>Animal</code>, <em>but not both</em>. In other words, if you pass in something that has a name <em>and</em> speed <em>and</em> legs, you’ll get an error.</p>
  </li>
  <li>
    <p>Because the object can only be one or the other type, the only property that is guaranteed to exist on the object is <code>name</code>. If we tried to access any other property on the object (without additional typecasting or narrowing), again, we’d get an error.</p>
  </li>
</ul>

<p>The <strong>union</strong> type operator <code>|</code> is used when we want instances that are exactly one of the component types specified.</p>

<h2 id="intersection">Intersection</h2>

<p>Now, we could also have an object (one that is currently untyped) called “horse”:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">horse</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">speed</span><span class="p">:</span> <span class="mi">23</span><span class="p">,</span>
    <span class="na">legs</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Spirit</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The horse is both a <code>Vehicle</code> and an <code>Animal</code>, because it literally has all of the fields necessary for both types. We can declare that using the following syntax:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Steed</span> <span class="o">=</span> <span class="nx">Vehicle</span> <span class="o">&amp;</span> <span class="nx">Animal</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">horse</span><span class="p">:</span> <span class="nx">Steed</span><span class="p">;</span>
</code></pre></div></div>

<p>A <code>Steed</code> can be passed into the <code>getName</code> function, and indeed, it can be used anywhere anyone asks for just a <code>Vehicle</code>, or just an <code>Animal</code>, because a <code>Steed</code> is truly both. That said, any variable defined as a <code>Steed</code> must have all the fields of both component types: we couldn’t assign “just” an <code>Animal</code> to a variable of the <code>Steed</code> type.</p>

<p>The <strong>intersection</strong> type operator <code>&amp;</code> is used when we want instances that can serve as <em>any</em> of the component types specified at <em>all</em> times.</p>

<h2 id="unknown-and-never">Unknown and Never</h2>

<p>Among Typescript’s special-case built-in types are two polar opposites, <code>unknown</code> and <code>never</code>. What do those types mean?</p>

<p>If a variable is an <code>unknown</code> type, then you can assign any value to it. <em>Anything. Always.</em> Likewise, a variable with a <code>never</code> type can not have anything assigned to it. <em>Nothing. At all.</em></p>

<p>The cases where you’d use either of these types are somewhat esoteric, and I won’t make a comprehensive list here. However, here are a few simpler motivating examples:</p>

<ul>
  <li>
    <p>A function that never returns (e.g. always throws an error or goes into an infinite loop) has a return type of, you guessed it, <code>never</code>. This signature is different from a return type of <code>void</code>, i.e. when the function does call <code>return;</code> with no value.</p>
  </li>
  <li>
    <p>A function parameter that could be a variety of things, determined through conditional checks (e.g. <code>if (param === undefined)</code>), could have a type of <code>unknown</code> if we were too lazy to create a more specific type.</p>
  </li>
</ul>

<h3 id="relation-to-set-theory">Relation to Set Theory</h3>

<p>How might we define <code>unknown</code> and <code>never</code> with our union and intersection operators? They would both be infinite sets—impractical to write explicitly in code—but the thought exercise will help us understand some interactions described later in this post.</p>

<p>The easier type to conceptualize this way is <code>unknown</code>. Consider: if we want the ability to assign any of three different types to a variable, what syntax would we use? Based on our <code>getName</code> function parameter, we’d do something like <code>A | B | C</code>. For five different types, we’d have <code>A | B | C | D | E</code>… and for truly <em>any type at all</em>, we’d have an infinitely-long union of types.</p>

<p>The more difficult type to discern in this way is <code>never</code>—although, given the parallels so far, the reader might be able to guess where we’re going. When we defined <code>Steed</code> as <code>Vehicle &amp; Animal</code>, we could no longer assign <code>Vehicle</code> or <code>Animal</code> alone to variables of that type. Furthermore, if we created a longer “intersection type” <code>A &amp; B &amp; C</code>, with more components, we’d get an increasingly restricted type. It follows that a variable with an infinitely-long intersection type could <em>never</em> take a value, because no value would have all the properties required of the type.</p>

<p>So, in summary: <code>unknown</code> is an infinite union of types; <code>never</code> is an infinite intersection of types.</p>

<h2 id="the-keyof-utility">The “keyof” Utility</h2>

<p>This little operator has a pretty simple use: it creates a type consisting of a <em>union</em> of the possible keys for an object.</p>

<p>Some code is worth a thousand words:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">legs</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Equivalent to ('name' | 'legs')</span>
<span class="kd">type</span> <span class="nx">AnimalKey</span> <span class="o">=</span> <span class="kr">keyof</span> <span class="nx">Animal</span><span class="p">;</span>
</code></pre></div></div>

<p>The union won’t always just be of strings, either: an array (for example) could yield numeric keys in that union.</p>

<h2 id="keyof-with-unions-and-intersections"><code>keyof</code> with Unions and Intersections</h2>

<p>Think of our old example types of <code>Vehicle</code>, <code>Animal</code>, and <code>Steed</code>. How would <code>keyof</code> behave with the union and intersection operators?</p>

<ul>
  <li>
    <p><code>keyof (Vehicle | Animal)</code> would only yield <code>'name'</code>. Does that feel a bit odd? Remember, <code>Vehicle | Animal</code> means that each value can only be one or the other type at any given time. When we apply <code>keyof</code>, the only guaranteed key on the object is the one shared between both types. That’s also why our function <code>getName</code> was restricted to referencing the <code>name</code> property.</p>
  </li>
  <li>
    <p><code>keyof Steed</code> (i.e. <code>keyof (Vehicle &amp; Animal)</code>) would naturally yield all three keys, <code>'name' | 'speed' | 'legs'</code>.</p>
  </li>
</ul>

<p>A union type typically <em>decreases</em> the number of valid keys, while an intersection type typically <em>increases</em> the number of valid keys.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>We have enough information now to consider the original question: What is <code>keyof never</code>? Or <code>keyof unknown</code>? The answer, while unintuitive, is quite logical!</p>

<p>Let’s start again with <code>unknown</code>:</p>

<ul>
  <li>
    <p><code>unknown</code> is an infinite union of types</p>
  </li>
  <li>
    <p>a union type typically decreases the number of valid keys</p>
  </li>
  <li>
    <p><code>keyof unknown</code> is an infinitely-shrunk set of keys, i.e. an empty set</p>
  </li>
</ul>

<p>The set theory explanation is still confusing, so think about it on a natural-language level. What property is valid for both Vehicles, and Animals, and Reports, and Electrons, and Arrays, and Numbers, and Strings, and anything else you can think of? True, a variable of type <code>unknown</code> will only ever be one of those actual types at any given time, but (as we saw in the <code>getName</code> function) we are only allowed to use keys that are shared across all possible types. The question we’re answering with <code>keyof unknown</code> is “what keys can be used at any time on values of any type anywhere in Typescript?”</p>

<blockquote>
  <p>Therefore, <code>keyof unknown</code> is <code>never</code>.</p>
</blockquote>

<p>What about <code>keyof never</code>?</p>

<ul>
  <li>
    <p><code>never</code> is an infinite intersection of types</p>
  </li>
  <li>
    <p>an intersection type typically increases the number of valid keys</p>
  </li>
  <li>
    <p><code>keyof never</code> is the maximal set of keys possible in Typescript, i.e. <code>String | Number | Symbol</code></p>
  </li>
</ul>

<p>When we combined two types, we got a type that had all the keys of both component types—even though we could no longer <em>assign</em> values of either component type to the intersection type. As we continue expanding that intersection type, we cover more and more keys, while making it more and more difficult to assign any value to the type… until we reach <code>never</code>. The question we’re answering with <code>keyof never</code> is “what keys could possibly, at some point, be syntactically valid in Typescript?”</p>

<blockquote>
  <p>Therefore, <code>keyof never</code> is <code>String | Number | Symbol</code>.</p>
</blockquote>

<h2 id="why-do-we-even-need-this">Why do we even need this?</h2>

<p>Admittedly, it’s mostly a fun thought exercise for me! But there is some marginal benefit.</p>

<p>If you are trying to define a variant of the <code>Record</code> type and want to provide no restrictions on what keys are used, you can use the generic type <code>K extends keyof never</code> to ensure that all valid key types are allowed (and, at the same time, preventing syntactically invalid key types). Granted, you could also use the more explicit <code>String | Number | Symbol</code>, and you’d be 99.9% sure to cover everything. However, if the language ever evolves in the future to allow a wider (or—somehow—narrower) set of key types, <code>keyof never</code> would by definition pick up on the change immediately, with no intervention necessary from the developer.</p>

<p>Crucially, I must urge the reader to not take this rationalization to their supervisors and tech leads in an attempt to justify unreadable code. The vast majority of developers will find it much easier to understand <code>String | Number | Symbol</code>. Saving that value in a readily-accessible type alias, with an explanatory code comment, is arguably much more maintainable than throwing <code>keyof never</code> everywhere. However, for those occasions when you see the latter in a codebase, and you’re confused as to how in the world that skeleton key works, think back to set theory. You just might be able to put yourself back on track!</p>

    
        <br/>
        <p>
            
                <a class="small tag" href="/tag/software">software</a>
            
        </p>
    

    <div class="clear"></div>

    
        <div id="disqus_thread"></div>
<script>
/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
 */
var disqus_config = function () {
this.page.url = "https://neillrobson.com/blog/2022/11/01/typescripts-skeleton-key/";  // Your page's canonical URL variable
this.page.identifier = "/blog/2022/11/01/typescripts-skeleton-key"; // Your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://neillrobson.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    
    
        <hr class="full"/>
    
    
        <a class="halfWidth left previousEntry" href="/blog/2020/11/23/grad-school-like-im-five/">
            <h5>Previous post</h5>
            <span class="title">Grad School Like I'm Five: Buffer Overflow</span>
            <span class="summary">According to GitHub, I’ve written approximately 6,000 lines of code over the course of the past four months (welcome to grad school!). The question is, can I explain all of the stuff I wrote?</span>
        </a>
    
    
        <a class="left halfWidth nextEntry" href="/blog/2023/03/06/invisalign-of-the-heart/">
            <h5>Next post</h5>
            <span class="title">Invisalign of the Heart</span>
            <span class="summary">For the second time in my life, I am undergoing the tedious and painful experience of tooth re-alignment. As a coping mechanism, why not pontificate on how Invisalign can serve as a spiritual allegory?</span>
        </a>
    
</div>


        <div class="clear"></div>
      </div>

      <div class="footer">
  <small class="copyright">
    &copy; 2024 Neill Robson. Layout inspired by
    <a href="https://blot.im/" target="_blank">Blot</a>.
    <br />
    This site is hosted at
    <a href="https://github.com" target="_blank">GitHub</a> and built with
    <a href="https://jekyllrb.com" target="_blank">Jekyll</a>.
  </small>
</div>

    </div>
    <script defer type="text/javascript" src="/assets/js/bundle.js"></script>


<script async id="dsq-count-scr" src="//neillrobson.disqus.com/count.js"></script>


  </body>
</html>
